<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>A-Frame Optokinetik - Punkte im Raster</title>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  </head>
  <body>
    <!-- A-Frame Szene -->
    <a-scene>
      <!-- Kamera und Bewegung -->
      <a-entity id="cameraRig" position="0 1.6 0" wasd-controls="acceleration: 50" look-controls="pointerLockEnabled: true">
        <a-camera></a-camera>
      </a-entity>

      <!-- Schwarzer Hintergrund -->
      <a-sky color="#000000"></a-sky>

      <!-- Kugel mit Punkten -->
      <a-entity id="points-group">
        <!-- Punkte werden durch JavaScript hinzugefügt -->
      </a-entity>

      <!-- Debugging Textanzeige -->
      <a-entity id="debugText" position="0 2 -2" text="value: Warten auf Eingabe...; color: yellow; width: 4;"></a-entity>

      <!-- VR-Button zum Starten/Stoppen der Animation -->
      <a-entity id="startButton" geometry="primitive: plane; width: 1; height: 0.5" material="color: green" position="0 1.5 -3" text="value: Start/Stop; align: center;" class="clickable"></a-entity>

      <!-- Script für das Erstellen der Punkte und Animation -->
      <script>
        const numberOfPoints = 1000;  // Anzahl der Punkte
        const radius = 20;  // Radius der Kugel
        const pointsGroup = document.getElementById('points-group');
        const debugText = document.getElementById('debugText');
        const startButton = document.getElementById('startButton');
        let isAnimating = false;  // Flag, um Animation zu steuern
        let gamepadButtonPressed = false;  // A-Button-Status für Controller

        // Zusätzliche Debugging-Ausgabe
        console.log("Script gestartet.");

        // Punkte im Raster erzeugen
        function createPoints() {
          const steps = Math.floor(Math.sqrt(numberOfPoints));  // Für ein gleichmäßiges Raster
          
          for (let i = 0; i < steps; i++) {
            const theta = (i / steps) * Math.PI * 2;  // Winkel um die Y-Achse

            for (let j = 0; j < steps; j++) {
              const phi = (j / steps) * Math.PI;  // Winkel um die X-Achse

              const point = document.createElement('a-sphere');
              point.setAttribute('radius', 0.1);  // Größe der Punkte
              point.setAttribute('color', '#FFFFFF');  // Farbe

              const x = radius * Math.sin(phi) * Math.cos(theta);
              const y = radius * Math.cos(phi);
              const z = radius * Math.sin(phi) * Math.sin(theta);
              
              point.setAttribute('position', `${x} ${y} ${z}`);
              point.setAttribute('theta', theta);
              point.setAttribute('phi', phi);

              pointsGroup.appendChild(point);
            }
          }

          console.log("Punkte erstellt.");
        }

        // Punkte animieren, indem sie um den Spieler rotieren
        function rotatePoints() {
          if (!isAnimating) return;  // Stoppe Animation, wenn Flag auf false steht
          const points = document.querySelectorAll('a-sphere');
          
          points.forEach((point) => {
            let theta = parseFloat(point.getAttribute('theta'));
            theta += 0.002;  // Rotationsgeschwindigkeit
            point.setAttribute('theta', theta);
            
            const phi = parseFloat(point.getAttribute('phi'));
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            point.setAttribute('position', `${x} ${y} ${z}`);
          });

          requestAnimationFrame(rotatePoints);  // Animation in Endlosschleife
        }

        // Punkte erstellen
        createPoints();

        // Funktion, die die Animation startet/stoppt und das Debugging-Text aktualisiert
        function toggleAnimation() {
          isAnimating = !isAnimating;  // Toggle Animation
          debugText.setAttribute('text', `value: Animation ${isAnimating ? 'gestartet' : 'gestoppt'}; color: ${isAnimating ? 'green' : 'red'}; width: 4`);
          console.log(`Animation ${isAnimating ? 'gestartet' : 'gestoppt'}`);
          if (isAnimating) rotatePoints();  // Starte die Animation, falls aktiviert
        }

        // Gamepad-Steuerung für die Animation
        function checkGamepad() {
          const gamepads = navigator.getGamepads();
          if (gamepads[0]) {
            const isPressed = gamepads[0].buttons[0].pressed;  // Taste A des Controllers
            if (isPressed && !gamepadButtonPressed) {
              gamepadButtonPressed = true;  // Setze Flag, wenn Taste gedrückt wurde
              toggleAnimation();  // Animation starten/stoppen
              debugText.setAttribute('text', `value: A-Taste gedrückt; color: yellow; width: 4`);
              console.log("A-Taste gedrückt");
            } else if (!isPressed && gamepadButtonPressed) {
              gamepadButtonPressed = false;  // Zurücksetzen, wenn Taste losgelassen wurde
              debugText.setAttribute('text', `value: A-Taste losgelassen; color: yellow; width: 4`);
              console.log("A-Taste losgelassen");
            }
          } else {
            debugText.setAttribute('text', `value: Gamepad nicht erkannt; color: red; width: 4`);
            console.log("Kein Gamepad erkannt.");
          }
          requestAnimationFrame(checkGamepad);  // Prüfe ständig auf Gamepad-Eingaben
        }

        // Event Listener für den VR-Button zum Starten/Stoppen
        startButton.addEventListener('click', function () {
          toggleAnimation();  // Animation starten/stoppen
          debugText.setAttribute('text', `value: VR-Button gedrückt; color: yellow; width: 4`);
          console.log("VR-Button gedrückt.");
        });

        // Gamepad-Überprüfung starten
        checkGamepad();
      </script>
    </a-scene>
  </body>
</html>
