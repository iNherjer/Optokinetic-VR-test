<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8">
    <title>A-Frame Optokinetik - Fehlerbehebte Version</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  </head>
  <body>
    <!-- A-Frame Szene -->
    <a-scene>
      <!-- Kamera und Bewegung -->
      <a-entity
        id="cameraRig"
        position="0 1.6 0"
        wasd-controls="acceleration: 50"
        look-controls="pointerLockEnabled: true"
      >
        <a-camera audio-listener></a-camera>
      </a-entity>

      <!-- Schwarzer Hintergrund -->
      <a-sky color="#000000"></a-sky>

      <!-- Kugel mit Punkten -->
      <a-entity id="points-entity" optimized-points></a-entity>

      <!-- Sound Asset -->
      <a-assets>
        <!-- Audiodatei im Hauptverzeichnis -->
        <audio id="hum-sound" src="hum-sound.mp3"></audio>
      </a-assets>

      <!-- Menü mit Buttons -->
      <!-- (Unverändertes Menü) -->

      <!-- Debugging Textanzeige -->
      <a-entity
        id="debugText"
        position="0 2 -2"
        text="value: Warten auf Eingabe...; color: yellow; width: 8;"
      ></a-entity>

      <!-- Controller für Interaktionen -->
      <a-entity laser-controls="hand: right" id="rightController"></a-entity>

      <!-- Script -->
      <script>
        AFRAME.registerComponent('optimized-points', {
          schema: {},
          init: function () {
            this.isAnimating = false;
            this.animationSpeed = 0.2;
            this.rotationAxis = new THREE.Vector3(0, 1, 0);
            this.totalRotationAngle = 0;
            this.scale = 1;
            this.numPoints = 2000;
            this.createPoints();
          },
          createPoints: function () {
            const radius = 20;
            const positions = new Float32Array(this.numPoints * 3);
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({
              color: 0xffffff,
              size: 0.05,
              sizeAttenuation: true,
            });

            for (let i = 0; i < this.numPoints; i++) {
              const theta = Math.random() * 2 * Math.PI;
              const phi = Math.acos(2 * Math.random() - 1);
              const x = radius * Math.sin(phi) * Math.cos(theta);
              const y = radius * Math.cos(phi);
              const z = radius * Math.sin(phi) * Math.sin(theta);
              positions[i * 3] = x;
              positions[i * 3 + 1] = y;
              positions[i * 3 + 2] = z;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.computeBoundingSphere();
            this.points = new THREE.Points(geometry, material);
            this.points.scale.set(this.scale, this.scale, this.scale);
            this.el.setObject3D('mesh', this.points);

            // Sound-Entity erstellen
            this.createSoundEntity();
          },
          createSoundEntity: function () {
            const soundEntity = document.createElement('a-entity');
            soundEntity.setAttribute('position', '30 0 0');
            soundEntity.setAttribute('sound', {
              src: '#hum-sound',
              autoplay: false,
              loop: true,
              positional: true,
              distanceModel: 'inverse',
              refDistance: 1,
              maxDistance: 100,
              rolloffFactor: 1,
              panningModel: 'HRTF',
            });
            this.el.appendChild(soundEntity);
            this.soundEntity = soundEntity;

            // Speichere die Anfangsposition
            this.initialSoundPosition = this.soundEntity.object3D.position.clone();
          },
          tick: function (time, timeDelta) {
            if (!this.isAnimating) return;
            const delta = timeDelta / 1000;
            const rotationAngle = this.animationSpeed * delta;

            this.totalRotationAngle += rotationAngle;

            const quaternion = new THREE.Quaternion();
            quaternion.setFromAxisAngle(this.rotationAxis, this.totalRotationAngle);

            this.points.quaternion.copy(quaternion);

            const rotatedSoundPosition = this.initialSoundPosition
              .clone()
              .applyQuaternion(quaternion);
            this.soundEntity.object3D.position.copy(rotatedSoundPosition);
          },
          toggleAnimation: function () {
            this.isAnimating = !this.isAnimating;
            const debugText = document.getElementById('debugText');
            debugText.setAttribute(
              'text',
              `value: Animation ${this.isAnimating ? 'gestartet' : 'gestoppt'}; color: ${
                this.isAnimating ? 'green' : 'red'
              }; width: 8`
            );
            console.log(`Animation ${this.isAnimating ? 'gestartet' : 'gestoppt'}`);

            const menu = document.getElementById('menu');
            if (this.isAnimating) {
              menu.setAttribute('visible', 'false');
              const soundComponent = this.soundEntity.components.sound;
              if (!soundComponent.isPlaying) {
                soundComponent.playSound();
              }
            } else {
              menu.setAttribute('visible', 'true');
              const soundComponent = this.soundEntity.components.sound;
              if (soundComponent.isPlaying) {
                soundComponent.stopSound();
              }
            }
          },
          // Weitere Funktionen bleiben unverändert
        });

        // Event Listener für die Buttons
        // (Unveränderte Event Listener)

        // Event Listener für den Trigger des Controllers
        const rightController = document.getElementById('rightController');

        rightController.addEventListener('triggerdown', function (evt) {
          console.log('Trigger gedrückt');
          const pointsEntity = document.getElementById('points-entity');
          pointsEntity.components['optimized-points'].toggleAnimation();
        });

        // Event Listener für die A- und B-Tasten des rechten Controllers
        // (Unveränderte Event Listener)
      </script>
    </a-scene>
  </body>
</html>
